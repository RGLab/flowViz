% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
%\VignetteIndexEntry{Visualizing Gates with Flow Cytometry Data}
%\VignetteDepends{flowViz}
%\VignetteKeywords{}
%\VignettePackage{flowViz}
\documentclass[11pt]{article}

\SweaveOpts{keep.source=TRUE,pdf=TRUE,eps=FALSE}


\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rdata}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}



\title{Gates/filters in Flow Cytometry Data Visualization} 
\date{\today}



\usepackage[text={7.5in,9in},centering]{geometry}
\usepackage{Sweave}
\setkeys{Gin}{width=0.95\textwidth}
\usepackage[round]{natbib}

\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}

% \usepackage{setspace}
% \setlength{\parindent}{0in}



\begin{document}
\maketitle

\begin{abstract}
  The \Rpackage{flowViz} package provides tools for visualization of
  flow cytometry data.  This document describes the support for
  visualizing gates (a.k.a. filters).
\end{abstract}

S

<<loadPackage, echo=false,results=hide>>=
library(flowViz)
@


\section{Introduction}
Tools to read in and otherwise manipulate flow cytometry data are
implemented in the \Rpackage{flowCore} package.  The
\Rpackage{flowViz} package provides visualization support for such
data.  In this document we give examples dealing with gated or
filtered data.




\subsection{Filters and filter results}
The \Rpackage{flowCore} package defines the concepts of filters and
filter results.  Filters are abstract entities defined in terms of
markers that are measured on the flow instrument as different
channels, whereas a filter result is the result of applying a filter
to one or more flow frames (data objects representing individual FCM
experiments).  Some filters are data driven, while some are not. We
will later see how this distinction has an impact on their plotting. All abstractions of filters or gates inherit from class \Rclass{filter}, whereas objects generated as the result of applying a  filter inherit from class \Rclass{filterResult}.


\subsection{Visualization}
Before we discuss how to visualie gates in \Rpackage{flowViz}, we need
to point out that this may only be reasonable for certain types of the
many possible plots, namely one-dimensional density plots and
two-dimensional scatter plots. Over time we might add gate-plotting
support for other plot types as well. There are two principal ways to
add gates to a flow cytometry plot; either we render the outlines of
the gate region (for both one and two-dimensional plots), or we
highlight the points within a gate region by distinctive color,
glyphs, or point size (this applies for two-dimensional plots only). It only makes
sense to visualize the boundaries of a filter if it has a (one or two dimensional)
geometric representation.  This is true for rectangle, ellipsoid and
polygon gates, which are all frequently used.  It is also true for
some data driven gates, e.g. \Rclass{norm2Filter} gates, which have a
(data dependent) spherical representation.  Also, it makes sense to
draw gate boundaries only when plotting (some of) the channels that define the
gate.

Visualizing \Rclass{filterResults} is more general.  Specifically,
the result of applying a filter is usually a logical (\Rcode{TRUE} or
\Rcode{FALSE}) vector for each cell, or more generally, a
\Rclass{factor} (as long as we restrict ourselves to non-fuzzy
filters).  This can be used as a grouping variable within a display, also when plotting channels other than those defining the gate.

All data-driven filters depend on the \Rclass{filterResult} to be
computed in order to plot them. The user doesn't have to worry about
this fact, as the software will implicitely compute these objects if
necessary. However, realizing filters and creating
\Rclass{filterResult} is often computationally intense and
time-consuming, and in many cases makes sense to explicitely
create the \Rclass{filterResult} once and pass it on to the plotting
functions instead of the input filter. In the course of this manual,
\Rclass{filter} objects and \Rclass{filterResults} may be used interchangeably, unless
stated otherwise.



\subsection{Example Data}
We use the \Rdata{GvHD} data set to provide some examples. It come as a serialized \Rclass{flowSet} with the \Rpackage{flowViz} package and the interested user is referred to its documentation for details. For the purose of this demonstration it is sufficient to know that the \Robject{phenoData} slot of the \Robject{GvHD} set contains several factor variables, \Robject{Patient} and \Robject{Visit} two of the most descriptive ones. In general, all \Rclass{flowSets} contain an implicit \Robject{name} variable which is is used as the default conditioning variable in all of \Rpackage{flowViz's} highlevel plotting functions.
<<loadData>>=
library(flowViz)
data(GvHD)
head(pData(GvHD))
@ 
%
The set is quite large and reducing it to a reasonable subset will
speed up things for our interactive demonstration purpose. Due to
various constrains (data size, conplexity of computations, limitations
in the \Rpackage{grid} software underlying the \Rpackage{lattice} and
\Rpackage{flowViz} packages), rendering plots is usually not
instantanious. It ususally takes a little bit of time to output
complex panel layouts. When producing postscript output, the user
should be aware that file size may become an issue, and we will
address solutions for this problem at the end of this document.

The \Rpackage{lattice} package offers in-line subsetting capabilities
for all high level plotting functions though the \Robject{subset}
argument, and this functionality (like most of the other typical \Rpackage{lattice} concepts) is also available for all derived plotting methods in \Rpackage{flowCore}. The general idea here is that all symbols defined in either the formula or one of the special arguments like \Robject{subset} are evaluated in the context of the \Rclass{flowFrame's} \Robject{phenoData} data frame or the raw data matrix. This is a slight extension of the fundamental \Rpackage{lattice} idea necessitated by the fact that raw data and annotation data are stored separately in a \Rpackage{flowSet}. 
<<subsetLattice, eval=FALSE>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD,
       subset=Patient=="6")
@ 
%
Inline subsetting is useful to change plots on the fly, or to play around with
various panel arangements. However, we still pass the whole
\Robject{GvHD} object down to the plotting function, potentially increasing memory usage and
decreasing performance due to
unnecessary heavy copying operations. Since we only want to use the subset
for patient 6 in the following examples, it makes sense to directly
subset the \Rclass{flowSet}.
<<subsetFlowCore>>=
GvHD <- GvHD[pData(GvHD)$Patient==6]
@ 
%
We also want to transform some of the fluorescence channels to an
adequate log-like scale:
<<transform>>=
tf <- transformList(from=colnames(GvHD)[3:7], tfun=asinh)
GvHD <- tf %on% GvHD
@ 
For details on this step, please see the documentation of the \Rfunction{transformList} and \Rfunction{\%on\%} functions in the \Rpackage{flowCore} package. 


\section{Filters in scatter plots}
Trellis scatter plots are created using \Rfunction{xyplot} methods. 
The \Rfunction{xyplot} method for \Rclass{flowSet} objects supports
filters through the \Rcode{filter} argument. As mentioned before, its
value can either be an object inheriting from class \Rclass{filter} or
a \Rclass{filterResult} (a \Rclass{filterResultList} of multiple
\Rclass{filterResults} for \Rclass{flowSets}).

The key concepts here are that
\begin{itemize}
  
\item \Rclass{filters} and \Rclass{filterResults} can be used
  interchangeably. Providing \Rcode{filterResults} directly may increase
  performance for data-driven filters. 
  
\item visualization of \Rclass{filters} depends on the type of
  rendering.  For example, with \Rcode{smooth=TRUE}, filters are
  visualized geometrically, which makes sense only under certain
  circumstances (e.g. display axes matching filter parameters, the
  \Rclass{filter} class has a geometric represention). For scatter
  plots of individual dots for all events (\Rcode{smooth=FALSE}),
  filters are visualized through grouping and/or geometric filter
  outlines; the former makes sense more generally, as display variables
  need not match filter parameters. Grouping has the drawback of
  overplotting.  The effect of overplotting can be reduced somewhat
  using transparency, but scalability issues remain.  We may try
  dealing with this at some point if it becomes enough of a hassle.
  
\item the software will check for matching parameters and available
  visualization representations as much as possible, yet finally it is
  up to the user to construct reasonable calls to the plotting
  functions.
\end{itemize}


\subsection{Simple Geometric Filter Types}
Visualization of most of the typical FCM filter types is straight
forward and doesn't require the computation of
\Rclass{filterResult}. All parameters (e.g. min and max
values in a recangular gate) are unambigously defined in the
\Rclass{filter} object. We will start with a simple
\Rclass{rectangleGate} in the \Robject{FSC-H} and \Robject{SSC-H}
dimensions. 

\newpage
<<simpleRG>>=
rgate <- rectangleGate("FSC-H"=c(0, 400),"SSC-H"=c(-50, 300))
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=rgate)
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage

As default for smoothed scatter plots, the gate boundaries are
drawn. Orientation of the gate will be handled by the plotting
function and the user doesn't have to worry about the order of arguments when defining
the \Rclass{filter}. The software also decides on a reasonable
two-dimensional geometric representation of more complex
filters. E.g., we can add a third dimension to the
\Rclass{rectangleGate} and still achive the same visualization in the
\Robject{FSC-H} and \Robject{SSC-H} dimensions.
<<threeDRG>>=
rgate2 <- rgate * rectangleGate("FL1-H"=c(2, 4))
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=rgate)
@ 
%
For the non-smoothed rendering, the default filter visualization uses
different colors for the different subpopulations. 

\newpage
<<nonSmoothScatter>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=rgate, smooth=FALSE)
@
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage

We can further add the \Rclass{filter} boundaries to the plot using
the \Robject{outline} argument.

\newpage
<<nonSmoothScatterOutline>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=rgate,
smooth=FALSE, outline=TRUE)
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage

The constraint for a valid two-dimensional representation don't apply
any more for this type of rendering. Since each event is represented by a
single point on the plot, we can visualize arbitrarily complex
\RClass{filters} using different colors or point glyphs for the different sub-populations.  Going back to our three-dimensional rectangle, we
notice that not all points within the rectangle are also color red,
because the additional third dimension further reduced the selection of positive events in the \Robject{FSC-H} and \Robject{SSC-H} dimensions.

\newpage
<<nonSmoothScatterOutline>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=rgate2,
smooth=FALSE, outline=TRUE)
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage


\subsection{Data-Driven Filters}
Data-driven filters don't have a natural geometric representation a
priori; they are data-drive. Once all parameters are estimated, we can
usually derive such a representation from the
\Rclass{filterResult}. There is only a small subet of \Rclass{filter}
classes for which this is not directly possible
(\Rclass{kmeansFilter}, \Rclass{timeFilter}), although one might be able to fall back to convex hulls or the like. So far, \Rpackage{flowViz} has nor support for plotting gate outlines of these filter types, and they are silently ignored when passed on as argument \Robject{filter} to any of the highlevel plotting functions. As shown in the previous
example, this only poses a problem when trying to plot filter
boundaries, the non-smooth representation of individual events is
available for virtually all \Rclass{filter} types. 

In the following example, we first compute the \Rclass{filterResults}
of a \Rclass{norm2Filter} in \Robject{FSC-H} and \Robject{SSC-H} for
each frame in our \Robject{GvHD} \Rclass{flowSet} and plot their
geometric elliptic representation.

\newpage
<<nonSmoothScatterOutline>>=
n2Filter <- norm2Filter("SSC-H", "FSC-H", scale=2)
n2Filter.results <- filter(GvHD, n2Filter)
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=n2Filter.results)
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage

There are data-driven filter types that may result in more than just one sub-population. \Rclass{curv1Filters} and \Rclass{curv2Filters} are a prominent example. In the next code chunk we use a \Rpclass{curv2Filter} to identify high-density areas in the \Robject{FSC-H} and \Robject{FL4-H} projections of the data.

\newpage
<<curv2Filter>>=
c2f <- curv2Filter("FSC-H", "FL4-H")
c2f.results <- filter(GvHD, c2f)
xyplot(`FL4-H` ~ `FSC-H` | Visit, data=GvHD, filter=c2f.results)
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage

This is a good example for a case when passing the \Rclass{filterResult} instead of the \Rclass{filter} is beneficial. Depending on the hardware it can take quite some time to complete the extensive computations necessary for the identification of siginficant high-density areas in 3D. Imaging you want to make slight changes to your plot (and producing good graphical output is almost always an iterative approach). Having to recompute the \Rpackage{filterResult} on each iteration would be very time-cosuming and annoying at best. 

\section{Filters in one-dimensional density plots}
The \Rpackage{lattice} package provides the highlevel \Rfunction{densityplot} function to draw one-dimensional Kernel density estimates of univariate data. Density estimates are a generalization of the well-known histograms; instead of drawing boxes of relative or absolute frequencies of binned observations, a continous relative density is displayed, usually beautified by applying a smoother function with an appropriate bandwidth. The \Rfunction{densityplot} methods in the \Rpackage{flowViz} package assume an implicit conditioning variable (the measurement channels) and display the density estimates of all frames as a stacked layout. This has proven to be a useful visualization, since the direct comparison of univariate channel distributions is of great interst in many FCM application, however the typically large number of samples makes superimposing in a single display impratical. See the documention of \Rfunction{densityplot} for more details. 

It only makes sense to plot filter boundaries in one-dimensional density plots. The densities are basically a summary of the distribution of events for a particular channel, and there is no real notion of individual points in a density plot. Similar to the \Rfunction{xyplot} methods, we can pass \Rclass{filters} or \Rclass{filterResults} to the function as optional argument \Robject{filter}. We decided to indicate gate boundaries by different shading of the the respective integrals of the density regions rather than simply adding vertical lines. These tend to be distracting in the stacked layout or to be partly masked by overplotting of neighbouring density areas.  

\newpage
<<densityplots>>=
densityplot(~ `FSC-H`, GvHD, filter=curv1Filter("FSC-H"))
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage


\section{Plotting parameters}
\Rpackage{Lattice} graphics are a great tool to easily create informative and consise data visualization with a minimal amount of code and most of the default graphical parameters are well thought through. However, there is also a wealth of customization available, and we refer readers to the package's documentation as well as the Deepayan Sarkar's excellent book ``Lattice Graphics'' (FIXME: citation) for details. With respect to \Rpackage{flowViz}, it should suffice to mention that customization follows the exact same principals defined in the \Rpackage{lattice} package. As a matter of fact, most customization actually happens at the level of the underlaying \Rpackage{lattice} software. The facts to mention are:

\begin{itemize}
\item There are session-wide global defaults that can be queried and set using the \Rfunction{flowViz.get.par} and \Rfunction{flowViz.set.par} functions. These are extensions to the \Rfunction{trellis.get.par} and \Rfunction{trellis.set.par} functions in the \Rpackage{lattice} package, and work in exactly the same way. All graphical parameters that are not defined in \Rpackage{flowViz} are directly passed on to \Rpackage{lattice}.
  
\item Parameters can also be set for a single function call using the \Robject{par.settings} argument. These setting take precedence over global settings.
  
\item Parameters are split up into logical categories and have to be provided as named lists or lists of lists. The categories directly relevant for filter plotting are \Robject{gate} and \Robject{gate.text}. See the documentation for \Rfunction{flowViz.par.set} for a complete list of available parameters. All additional graphical parameters (like \Robject{cex}, \Robject{pch} and \Robject{col}) known from the \Rpackage{lattice} highlevel plotting functions are also still available.
  
\end{itemize}


\newpage
<<plotPars1>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit, data=GvHD, filter=rgate,
       par.settings=list(gate=list(fill="black", alpha=0.2)))
@ 
%
\begin{center}
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@
\end{center}
\newpage


\section{Restrictions on the formula interface}
We mentioned before that all elements of the formulae used in \Rpackage{flowViz} are evaluated in the context of either the raw data matrix or the \Robject{phenoData} slot. This implies that formula components can themselve be valid R expressions including fuction calls. To a certain extend this is true, and the user might be able to produce reasonable graphical output by evaluating expressions around existing data or annotation objects, however we strongly discourage this use. The software makes certain assumptions on the relationship between gate definitions and data, on being the fact that both are on the same scale. The use of expressions in \Rpackage{flowViz} potentially changes the scale of the raw data, in which case the gate representation doesn't make much sense anymore. Furthermore, FCM data is naturally censored (by the available measurement range of the instrument) and we try to protect the user from irritating visual artifacts caused by the piling up of events on the margins of the data range. This is most notably in the one-dimensional densityplots, where densities are only computed within the data range, and margin events are added as vertical bars. Similarily, in the two-dimensional smoothed scatter plots we display margin events as ticks around the actual data display. Again, changing the scale of the data would potentially invalidate many of the necessary computations. 

\Rpackage{lattice} encourages the use of expressions in the formula interface and for the sake of customizability we didn't want to exclude this feature completely in the \Rpackage{flowViz} methods, however this tool has to be used with great care, and particularily when plotting gates you get what you deserve if you don't.



In this figure, \Rcode{n2gate} is again applied to each frame, but
this time to the inline-transformed \Rclass{flowSet} object suppiled
as the \Rcode{data} argument.  Since \Rcode{smooth=FALSE}, the subset
of points in the gate are shown in a different color
(\Rcode{filterResults} is computed by applying \Rcode{filter} to each
frame).  Making the points translucent allows us to get a feel of the
local density of points.



\newpage


<<>>=
xyplot(`SSC-H` ~ `FSC-H` | Patient:Visit,
       data = transform("SSC-H"=asinh,"FSC-H"=asinh) %on% GvHD,
       subset = Patient == "6",
       filter = rgate)
##
@ 

\begin{center}
  
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@

\end{center}
In this figure, the rectagle gate \Rcode{r2gate} is rendered on the
transformed data.




\newpage


<<>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit,
       data = transform("SSC-H"=asinh,"FSC-H"=asinh) %on% GvHD,
       subset = Patient == "6",
       filterResults = n2gate.results,
       smooth = FALSE, alpha = 0.1)
##
@ 

\begin{center}
  
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@

\end{center}
In this figure, there is no \Rcode{filter} argument.  However, there
is a \Rcode{filterResults} argument, which has been set to
\Rcode{n2gate.results}.  Note that the filter was originally applied
to untransformed data, but the data being displayed is transformed.
Consequently, the boundaries of the points in the gate are not
ellipses in the display scale.


\newpage


<<>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit,
       data = transform("SSC-H"=asinh,"FSC-H"=asinh) %on% GvHD,
       subset = Patient == "6",
       filterResults = n2gate.results,
       filter = n2gate,
       smooth = FALSE, alpha = 0.1)
##
@ 

\begin{center}
  
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@

\end{center}
In this figure, we have both a \Rcode{filter} and a
\Rcode{filterResults} argument.  The effect of \Rcode{filterResults}
is exactly as it was in the previous plot.  However, \Rcode{filter} is
applied anew, and rendered as ellipses, on the \emph{transformed}
data.  As we can see, both versions localize the primary cluster in
roughly the same region, except in one case.



\newpage


<<>>=
xyplot(`SSC-H` ~ `FSC-H` | Visit,
       data = transform("SSC-H"=asinh,"FSC-H"=asinh) %on% GvHD,
       subset = Patient == "6",
       smooth = FALSE, alpha = 0.1,
       filter = rectangleGate("FSC-H"=c(5.5, 7),"SSC-H"=c(4, 6.5)),
       filterResults = n2gate.results,
       displayFilter = list(border = 'red'))
##
@ 

\begin{center}
  
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@

\end{center}
This figure is in principle similar to the previous one, except that
\Rcode{filter} is now the rectangle gate.



\newpage


<<>>=
xyplot(asinh(`FL3-H`) ~ asinh(`FL1-H`) | Visit, data = GvHD,
       subset = Patient == "6",
       smooth = FALSE, alpha = 0.1,
       filter = rectangleGate("FSC-H"=c(5.5, 7),"SSC-H"=c(4, 6.5)),
       filterResults = n2gate.results,
       displayFilter = list(border = 'red'))
##
@ 

\begin{center}
  
<<fig=TRUE,width=9,height=5,echo=FALSE>>=
plot(trellis.last.object())
@

\end{center}
As noted earlier, rendering a filter only makes sense when variables
match, whereas a filter result can be used for grouping even when this
does not hold.  In this figure, a \Rcode{filter} argument is
specified, but it is ignored because the parameters of the filter are
not being plotted.  However, \Rcode{filterResults} is still used.



\newpage

\section{Filters in parallel coodinate plots}


Although the \Rcode{filter} argument does not make much sense except
in scatter plots, \Rcode{filterResults} can be used for grouping in
other contexts.  So far, only the \Rfunction{parallel} method supports
this syntax.


<<>>=
parallel(~ . | Visit, 
         data =
         transform("SSC-H"=asinh,"FSC-H"=asinh, "FL1-H"=asinh,
                   "FL2-H"=asinh, "FL3-H"=asinh, "FL2-A"=asinh,
                   "FL4-H"=asinh) %on% GvHD,
         subset = Patient == "6",
         filterResults = n2gate.results,
         alpha = 0.01)
##
@ 

\begin{center}
  
<<fig=TRUE,width=9,height=8,echo=FALSE>>=
plot(trellis.last.object())
@

\end{center}






\clearpage

% \bibliographystyle{plainnat} 
% \bibliography{cytoref}

\end{document}
