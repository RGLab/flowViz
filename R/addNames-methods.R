## ==========================================================================
## for rectangleGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="rectangleGate", name="character"), 
          function(x, name, data, gp,pos=0.5,abs=FALSE)
      {
#		  browser()
          parms <- parameters(x)
          xlim <- state("xlim")
          ylim <- state("ylim")
		  
#		  browser()
		  
          ## 1D rectangular gate (region gate).
          if(length(parms)==1){
              mt <- match(parms, data)
              if(mt==1){
				  xx<-c(x@min,x@max)
				  yy <- ylim
              }else if(mt==2){
				  yy<-c(x@min,x@max)
				  xx <- xlim
              }else stop("How did you end up here????")
          }else{## 2D rectangular gate   
              bl <- x@min[data]
              tr <- x@max[data]
			  xx<-c(bl[1], tr[1])
			  yy<-c(bl[2], tr[2])
#              gltext(mean(xx), mean(yy), labels=name, adj=0.5, gp=gp)
          }
		  
		  if(abs)#plot label whithin the boundary by default 
		  {
			  xx<-xlim
			  yy<-ylim
		  }else #specify location by absolute position of the current window
		  {
			  
			  xx<-fixBound_addName(xx,xlim)
			  yy<-fixBound_addName(yy,ylim)
		  }
		  pos <- rep(pos, length=2)[1:2]
		  xx<-xx[1]+diff(xx)*pos[1]
		  yy<-yy[1]+diff(yy)*pos[2]
		  
		  gltext(xx, yy, labels=name, adj=0.5, gp=gp)
          return(invisible())
      })


setMethod("addName",
          signature(x="rectangleGate", name="logical"), 
          function(x, name, ...)
      {
          if(name)
              addName(x, paste(identifier(x), "+", sep=""), ...)
          else
              return(invisible())
      })



## ==========================================================================
## for ellipsoidGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="ellipsoidGate", name="character"), 
          function(x, name, data, gp)
      {
          gltext(x@mean[data[1]], x@mean[data[2]], labels=name, adj=0.5, gp=gp)
          return(invisible())
      })

setMethod("addName",
          signature(x="ellipsoidGate", name="logical"), 
          function(x, name, ...)
      {
          if(name)
              addName(x, paste(identifier(x), "+", sep=""), ...)
          else
              return(invisible())
      })



## ==========================================================================
## for quadGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="quadGate", name="matrix"), 
          function(x, name, data, gp)
      {
          v <- x@boundary[data[1]]
          h <- x@boundary[data[2]]
          xlim <- state("xlim")
          ylim <- state("ylim")
          yoff <- diff(ylim)/50
          trans <- match(colnames(name)[1], data)-1
          if(trans)
              name <- matrix(c(name[2,2], name[2,1], name[1,2],
                                name[1,1]), ncol=2)
          gltext(c(mean(c(xlim[1], v)), mean(c(v, xlim[2]))),
                 rep(ylim[2], 2)-yoff, labels=name[1,],
                 adj=c(0.5, 1), gp=gp)
          gltext(c(mean(c(xlim[1], v)), mean(c(v, xlim[2]))),
                 rep(ylim[1], 2)+yoff, labels=name[2,],
                 adj=c(0.5, 0), gp=gp)
          return(invisible())
      }) 

setMethod("addName",
          signature(x="quadGate", name="logical"), 
          function(x, name, data, ...)
      {
          if(name){
              desc <- flowCore:::popNames(data, x)
              names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
                                sprintf("%s-%s-", desc[1], desc[2]),
                                sprintf("%s+%s+", desc[1], desc[2]),
                                sprintf("%s+%s-", desc[1], desc[2])),
                              ncol=2)
              colnames(names) <- names(desc)
              data <- checkParameterMatch(parameters(x), verbose=FALSE)
              addName(x, names, data, ...)
          }else
          return(invisible())
      })
    
setMethod("addName",
          signature(x="quadGate", name="character"), 
          function(x, name, data, ...)
      {
          desc <- flowCore:::popNames(data, x)
          data <- checkParameterMatch(parameters(x), verbose=FALSE)
          names <- matrix(rep(name, 4)[4:1], ncol=2, dimnames=list(NULL, data))
          colnames(names) <- names(desc)
          addName(x, names, data, ...)
          return(invisible())
      })



## ==========================================================================
## for polygonGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="polygonGate", name="character"), 
          function(x, name, data, gp,pos=0.5,abs=FALSE)
      {
		  xlim <- state("xlim")
		  ylim <- state("ylim")
		  
		  if(abs)#plot label whithin the boundary by default 
		  {
			  xp<-xlim
			  yp<-ylim
		  }else #specify location by absolute position of the current window
		  {
			  xp <- range(x@boundaries[,data[1]])
			  yp <- range(x@boundaries[,data[2]])
			  xp<-fixBound_addName(xp,xlim)
			  yp<-fixBound_addName(yp,ylim)
		  }
		  pos <- rep(pos, length=2)[1:2]
		  
  		  xp<-xp[1]+diff(xp)*pos[1]
		  yp<-yp[1]+diff(yp)*pos[2]
	  		 
          
          gltext(xp, yp, labels=name, adj=0.5, gp=gp)
          return(invisible())
      })

setMethod("addName",
          signature(x="polygonGate", name="logical"), 
          function(x, name, ...)
      {
          if(name)
              addName(x, paste(identifier(x), "+", sep=""), ...)
          else
              return(invisible())
      })



## ==========================================================================
## for curv1Filter
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="curv1Filter", name="character"), 
          function(x, name, data, ...)
      {
          fd <- filterDetails(data, identifier(x))
          bounds <- fd$boundaries
          if(all(is.na(bounds[[1]])))
              return(invisible())
          data <- checkParameterMatch(parameters(x), verbose=FALSE)
          lb <- length(bounds)
          name <- rep(name, lb)
          for(i in 1:lb){
              tmp <- matrix(bounds[[i]], nrow=2)
              colnames(tmp) <- parameters(x)
              addName(x=rectangleGate(.gate=tmp, filterId=name[i]),
                      name=name[i], data=data, ...)
          }
          return(invisible())
      })

setMethod("addName",
          signature(x="curv1Filter", name="logical"), 
          function(x, name, data, ...)
      {
          if(name)
              addName(x, names(data)[-1], data=data, ...)
          else
              return(invisible())
      })



## ==========================================================================
## for curv2Filter
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="curv2Filter", name="character"), 
          function(x, name, data, ...)
      {
          fd <- filterDetails(data, identifier(x))
          bounds <- fd$polygon
          data <- checkParameterMatch(parameters(x), verbose=FALSE)
          lb <- length(bounds)
          name <- rep(name, lb)
          for(i in 1:lb){
              tmp <- cbind(bounds[[i]]$x, bounds[[i]]$y)
              colnames(tmp) <- parameters(x)
              addName(x=polygonGate(.gate=tmp, filterId=name[i]),
                      name=name[i], data=data, ...)
          }
          return(invisible())
      })

setMethod("addName",
          signature(x="curv2Filter", name="logical"), 
          function(x, name, data, ...)
      {
          if(name)
              addName(x, names(data)[-1], data=data, ...)
          else
              return(invisible())
      })



## ==========================================================================
## for kmeansFilter
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="kmeansFilter", name="character"), 
          function(x, name, data, gp, ...)
      {
          chan <- checkParameterMatch(parameters(x), verbose=FALSE)
          loc <- sapply(data, function(x) colMeans(exprs(x)[,chan]))
          gltext(loc[1,], loc[,2], labels=name, adj=0.5, gp=gp)
          return(invisible())
      })

setMethod("addName",
          signature(x="kmeansFilter", name="logical"), 
          function(x, name, data, ...)
      {
          if(name)
              addName(x, names(data), data=data, ...)
          else
              return(invisible())
      })







