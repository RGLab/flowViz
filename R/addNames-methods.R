## ==========================================================================
## for rectangleGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="rectangleGate", name="character"), 
          function(x, name, data, gp)
      {
          parms <- parameters(x)
          xlim <- state("xlim")
          ylim <- state("ylim")
          ## 1D rectangular gate (region gate).
          if(length(parms)==1){
              mt <- match(parms, data)
              if(mt==1){
                  xx <- c(fixInf(x@min, xlim), fixInf(x@max, xlim))
                  gltext(mean(xx), ylim[2], labels=name, pos=1, gp=gp)
              }else if(mt==2){
                  yy <- c(fixInf(x@min, ylim), fixInf(x@max, ylim))
                  gltext(xlim[1], mean(yy), labels=name, pos=4, gp=gp)
              }else stop("How did you end up here????")
          }else{## 2D rectangular gate   
              bl <- x@min[data]
              tr <- x@max[data]
              xx <- c(fixInf(bl[1], xlim), fixInf(tr[1], xlim))
              yy <- c(fixInf(bl[2], ylim), fixInf(tr[2], ylim))
              gltext(mean(xx), mean(yy), labels=name, adj=0.5, gp=gp)
          }
          return(invisible())
      })


setMethod("addName",
          signature(x="rectangleGate", name="logical"), 
          function(x, name, ...)
      {
          if(name)
              addName(x, paste(identifier(x), "+", sep=""), ...)
          else
              return(invisible())
      })



## ==========================================================================
## for ellipsoidGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="ellipsoidGate", name="character"), 
          function(x, name, data, gp)
      {
          gltext(x@mean[data[1]], x@mean[data[2]], labels=name, adj=0.5, gp=gp)
          return(invisible())
      })

setMethod("addName",
          signature(x="ellipsoidGate", name="logical"), 
          function(x, name, ...)
      {
          if(name)
              addName(x, paste(identifier(x), "+", sep=""), ...)
          else
              return(invisible())
      })



## ==========================================================================
## for quadGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="quadGate", name="matrix"), 
          function(x, name, data, gp)
      {
          v <- x@boundary[data[1]]
          h <- x@boundary[data[2]]
          xlim <- state("xlim")
          ylim <- state("ylim")
          yoff <- diff(ylim)/50
          trans <- match(colnames(name)[1], data)-1
          if(trans)
              name <- matrix(c(name[2,2], name[2,1], name[1,2],
                                name[1,1]), ncol=2)
          gltext(c(mean(c(xlim[1], v)), mean(c(v, xlim[2]))),
                 rep(ylim[2], 2)-yoff, labels=name[1,],
                 adj=c(0.5, 1), gp=gp)
          gltext(c(mean(c(xlim[1], v)), mean(c(v, xlim[2]))),
                 rep(ylim[1], 2)+yoff, labels=name[2,],
                 adj=c(0.5, 0), gp=gp)
          return(invisible())
      }) 

setMethod("addName",
          signature(x="quadGate", name="logical"), 
          function(x, name, data, ...)
      {
          if(name){
              desc <- flowCore:::popNames(data, x)
              names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
                                sprintf("%s-%s-", desc[1], desc[2]),
                                sprintf("%s+%s+", desc[1], desc[2]),
                                sprintf("%s+%s-", desc[1], desc[2])),
                              ncol=2)
              colnames(names) <- names(desc)
              data <- checkParameterMatch(parameters(x), verbose=FALSE)
              addName(x, names, data, ...)
          }else
          return(invisible())
      })
    
setMethod("addName",
          signature(x="quadGate", name="character"), 
          function(x, name, data, ...)
      {
          desc <- flowCore:::popNames(data, x)
          data <- checkParameterMatch(parameters(x), verbose=FALSE)
          names <- matrix(rep(name, 4)[4:1], ncol=2, dimnames=list(NULL, data))
          colnames(names) <- names(desc)
          addName(x, names, data, ...)
          return(invisible())
      })



## ==========================================================================
## for polygonGates
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="polygonGate", name="character"), 
          function(x, name, data, gp)
      {
          xp <- x@boundaries[,data[1]]
          yp <- x@boundaries[,data[2]]
          gltext(mean(xp), mean(yp), labels=name, adj=0.5, gp=gp)
          return(invisible())
      })

setMethod("addName",
          signature(x="polygonGate", name="logical"), 
          function(x, name, ...)
      {
          if(name)
              addName(x, paste(identifier(x), "+", sep=""), ...)
          else
              return(invisible())
      })



## ==========================================================================
## for curv1Filter
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="curv1Filter", name="character"), 
          function(x, name, data, ...)
      {
          fd <- filterDetails(data, identifier(x))
          bounds <- fd$boundaries
          if(all(is.na(bounds[[1]])))
              return(invisible())
          data <- checkParameterMatch(parameters(x), verbose=FALSE)
          lb <- length(bounds)
          name <- rep(name, lb)
          for(i in 1:lb){
              tmp <- matrix(bounds[[i]], nrow=2)
              colnames(tmp) <- parameters(x)
              addName(x=rectangleGate(.gate=tmp, filterId=name[i]),
                      name=name[i], data=data, ...)
          }
          return(invisible())
      })

setMethod("addName",
          signature(x="curv1Filter", name="logical"), 
          function(x, name, data, ...)
      {
          if(name)
              addName(x, names(data)[-1], data=data, ...)
          else
              return(invisible())
      })



## ==========================================================================
## for curv2Filter
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="curv2Filter", name="character"), 
          function(x, name, data, ...)
      {
          fd <- filterDetails(data, identifier(x))
          bounds <- fd$polygon
          data <- checkParameterMatch(parameters(x), verbose=FALSE)
          lb <- length(bounds)
          name <- rep(name, lb)
          for(i in 1:lb){
              tmp <- cbind(bounds[[i]]$x, bounds[[i]]$y)
              colnames(tmp) <- parameters(x)
              addName(x=polygonGate(.gate=tmp, filterId=name[i]),
                      name=name[i], data=data, ...)
          }
          return(invisible())
      })

setMethod("addName",
          signature(x="curv2Filter", name="logical"), 
          function(x, name, data, ...)
      {
          if(name)
              addName(x, names(data)[-1], data=data, ...)
          else
              return(invisible())
      })



## ==========================================================================
## for kmeansFilter
## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## 'names' either uses population names generated by the filter
## or can be a character provided by the user.
setMethod("addName",
          signature(x="kmeansFilter", name="character"), 
          function(x, name, data, gp, ...)
      {
          chan <- checkParameterMatch(parameters(x), verbose=FALSE)
          loc <- sapply(data, function(x) colMeans(exprs(x)[,chan]))
          gltext(loc[1,], loc[,2], labels=name, adj=0.5, gp=gp)
          return(invisible())
      })

setMethod("addName",
          signature(x="kmeansFilter", name="logical"), 
          function(x, name, data, ...)
      {
          if(name)
              addName(x, names(data), data=data, ...)
          else
              return(invisible())
      })







